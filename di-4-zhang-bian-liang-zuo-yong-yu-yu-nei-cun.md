---
description: 'KEYWORDS: 原始值, 引用值, 深拷贝和浅拷贝'
---

# 第4章 变量、作用域与内存

## **4.1 原始值和引用值(3)**

因为JS属于弱类型语言，所以JS的变量类型是不定的。

这是一把双刃剑，增加了便利性，消减了可维护性。或者换句话说，"前期编程爽，维护XX场"。所以当代大型前端项目都要实现TS(TypeScript)化，因为没有类型约束的项目终究走不长远。

JS里的数据只有两个大类型：**原始值**和**引用值**。

* 原始值：Number,String,Symbol,Undefined,Null,Boolean这6大类型都是原始值。
* 引用值：所有的对象，因为JS不允许直接操作对象所在的内存空间，所以引用值实际上是这些对象在内存的地址而非这些对象本身。

而在JS中，变量之间的数据传递书上说的不按“引用传递”，都是“按值传递”。实际上可能是翻译的问题，这里的“引用”指的就是对象本身，但是我们通常理解的“引用”是指的对象的地址（其实我们把JS里对象的值理解为对象的地址就好了，那么所有传递都是按值传递没有问题）。所以我们把书里的“值”实际上分为两种情况：

* 第一种情况是：如果某变量是原始类型，那么它就直接传递该值给其他变量。传递过后两个变量没有任何关系，可以独立操作。
* 第二种情况是：如果变量是引用类型，那么它就直接传递该对象的地址给其他变量（因为本身该变量的值就是对象的地址，所以这也是该变量的值）。所以单纯的传递地址会让多个变量指向同一个对象。

```javascript
const a = 1 // 值是一个原始类型
const b = a // a将值传递给b，所以b的值是1
const c = {} // 值是一个引用类型
const d = c // c将值传递给d，该值是一个地址，所以d是对象的地址
d.name = 'tuntun'
c.name // 'tuntun' 
```

第一种情况比较好理解，主要是第二种情况有时候不注意的话会出意料之外的情况，特别是在某些函数以引用值为参数时。

```javascript
function setName(obj){
// 这个obj实际上是函数内部作用域的局部变量
  obj.name = "Nicholas";
  // obj被指向了一个新对象 
  obj = new Object(); 
  obj.name = "Greg";
  return obj // 此时返回的是name为Greg的对象的引用，而非你传进来的引用了   
}
// 这是书中的例子，其实我们最关键的就是要理解obj实际上是我们在函数内部声明的一个新变量。
// 该变量指向外部传进的对象的地址，并且该指向在函数内部被修改了。
```

所以我们只需记住一句话：<mark style="color:red;">JS里的对象我们只能通过引用来操作(因为没有引用的对象都被销毁了。。。)</mark>。所以任何关于对象的读写，我们只需<mark style="color:red;">把对象本身和该对象的引用分开理解</mark>，就不会造成意外情况。

以上问题也引申出了一个大问题，**我们怎么复制对象而不是复制对象的引用**？

在任何面向对象的语言中，都会有一个经典问题：**怎么实现深拷贝和浅拷贝**？

* 浅拷贝：被拷贝对象内部含有引用类型，此时就不再拷贝引用类型的内容，而是拷贝引用就OK了
* 深拷贝：将被拷贝对象内部嵌套的引用类型完全拷贝下来。

```javascript
const a = [1,[2,3,[4,5]]
// 我们怎么深拷贝这个数组?
// 方法1
function copy(a){
 const b = []
 for(let i = 0; i < a.length; i++){
    b[i] = a[i]
 }
 return b   
}
b = copy(a) // [1,[2,3,[4,5]] , 虽然看起来一样，但是只完成了浅拷贝,里面的嵌套数组指向了同一个数组
// 方法2
function deepCopy(a){
   const newArray = []
   for(let i = 0; i < a.length; i++){
      if(typeof a[i] === 'object') { // 如果想精确一点，可以使用第3章里的Object.prototype.toString()
         // 此时我们需要递归地获取该二级数组
         newArray[i] = deepCopy(a[i])
      } else {
         newArray[i] = a[i]
      }
   }
   return newArray
}

// 另外，我们怎么深拷贝一个对象呢。涉及到两个问题：1 如何遍历一个对象的key 2 如何在key指向一个
// 嵌套对象的情况下继续深入拷贝
function deepCopyObj(obj) {
   const newObj = {}
   // 使用for-in 遍历, 这样的可以拷贝obj的可遍历属性
   // 还可以使用Object.entries(obj)来获取obj的key,value
   for(let key in obj){
         newObj[key] = typeof obj[key] !== ('object' || 'function') ? deepCopyObj(obj[key]) : obj[key] 
   }
   return newObj
}
// 测试一下
const a = {a:1 ,b:{c:1,d:{e:5}}}
const b = deepCopyObj(a)
console.log(b.b === a.b) // false，证明深拷贝成功了

// 我们可以发现两个方法实际上结构都类似，我们可以合并一下，是参数既可以是数组也可以是对象
function deepCopy(obj) {
    // 先判断obj的类型,使用instanceof 来判断会更精准一点
    const a = obj instanceof Array ? [] : {}
    // 使用ES2017新API Object.entries()遍历obj
    // [key,value]是ES6引入的解构赋值
    for([key,value] of Object.entries(obj)) {
       a[key] = typeof value === ('object' || 'function') ? deepCopyObj(value) : value
    }
    return a
}
// 测试一下
const a = [1,2,3,[4,5,6,{a:1,b:2}]]
const b = deepCopyObj(a)
console.log(b) // [1,2,3,[4,5,6,{a:1,b:2}]]
console.log(b[3][3] === a[3][3])  // false 这两个嵌套引用不指向同一个对象了
```

## 4.2 执行上下文、作用域链、标识符查找(3)

我们在JS中常听的两个词：上下文（context）/ 作用域（scope）确定了我们在任意位置访问变量的“范围”，举个例子：你去鸭蛋店说“给我5个蛋”，老板会给你5个鸭蛋，你去鸡蛋店老板说同样的话则会给你5个鸡蛋。同样都是蛋，因为环境不同，你拿到的却是完全不同的蛋。

我们访问变量也遵循这样的现象，例如你要访问a变量，那么JS引擎做的第一件事就是搞清楚你要访问哪里的a（因为你的代码可能有多个作用域，每个作用域都有a），那么查找该变量的顺序就形成了作用域链。再举个例子：你坐在电脑前，想找你的耳机。你查找的顺序通常是：先摸裤兜，再看桌面，要是桌面没有。你会看房间的其他位置，例如床上，枕头边啥的。要是你的房间再没有，你就会去你的客厅，餐桌上上找。你发现规律了吗：**查找满足就近原则**，找不到再去远处,找到了就不再继续找了。那么JS的作用域链也满足该条件。

还有一个特点，就是**查找只能从当前最近作用域往外找，不能往里找**。就像你没钱了，你可以找你爸要，你爸不给就找你爷爷要，但是你一般不会找你儿子要（要是你儿子是马云，随便要）。

在JS中，我们常用有三个作用域：**全局作用域，函数作用域，块作用域**(因为在for循环中实际上小括号里也是一个作用域)。全局作用域是最上层的唯一的作用域，函数/块作用域可以互相嵌套。

在浏览器中，作用域链会被实例化为一个你无法访问的对象\[\[Scopes]]。JS引擎在执行代码时，首先会确定当前最近的作用域。例如下图中你在全局下创建了一个函数，那么该函数最近的作用域就是全局作用域下。\[\[Scopes]]只有一个对象，那么就是全局作用域对象Global。

![](.gitbook/assets/image.png)

如果你手动创建了一个块级作用域，并声明一个了局部变量。并在里面再声明一个函数。

![](<.gitbook/assets/image (1).png>)

可以看到\[\[Scopes]]有两个对象了，第一个是一个Block(块作用域)对象，里面只有一个属性，就是你定义的块级变量b。

程序执行时，当前的\[\[Scopes]]会随着代码执行作用域的切换而切换。其实这个\[\[Scopes]]本质是一个栈，只能从一端进出。当栈顶找不到你想要的变量时，会弹出栈顶元素，继续查找栈顶，直到全局作用域被弹出。栈空了还找不到，那么就要报Referrence Error了。

学习作用域要联系第3章的变量声明说明：[#3.1.1-bian-liang-sheng-ming-3](di-3-zhang-yu-yan-ji-chu.md#3.1.1-bian-liang-sheng-ming-3 "mention"), 主要是熟悉TDZ，声明提前等特点。

我们再来看几个例子：

```javascript
const a = 1  // 全局下声明了一个a a1
for(let a = 1; a < 5; a++){ // 在for内实际声明了一个局部的a只用于迭代 a2
    let a = 2   // 块作用域下的a a3
    while(a) { // a3
        let a = 1 // 块作用域a4
        a-- // a4
    }
    console.log(a)
}
console.log(a)
// 请问执行这一段，会输出什么？
//                                                                         答案是： 什么都不会输出，无限循环，因为作用域链的存在，最内层的while里的a不会减少。因为这个a是a3
```

```javascript
const a = 1
f()
function f(){
    console.log(a)
    if(false){
        var a = 2
    }
}
// console的输出是？
//                                                                            答案是： undefined
// 因为var会在函数作用域里生效,且var自带声明提前，所以会在f执行前先在内部声明了a。
// 不要觉得if里的代码没执行就没用，在执行之前JS引擎会先解析一遍代码，并将var里的变量提前到当前作用域的最前方。
// 根据就近查找原则，那么f执行时会先在自己的作用域里查看有没有声明的a，在头部就查找到了a，直接就返回了，此时a还没有赋值

```

```javascript
const a = 1
f()
function f(){
    console.log(a)
    if(true){
        let a = 2
    }
}
// console的输出是？
//                                                                              答案是：1
// let没有声明提前了，所以在f内部没有声明的a，只能向外找到全局下的a。
```

上面两个例子也凸显了var的迷惑，以后大家的新项目就对var说再见吧。

## 4.3 垃圾回收(2)

前面说过，JS中我们无法直接操作内存里的对象（不像C++），直白地说就是我们无法直接对内存进行读写, 都是JS引擎代理了我们的操作。那么我们如果创建的对象，函数，变量不再使用了，为了避免内存泄漏，JS引擎就会负责把我们**不需要的数据**清理掉以腾出内存完成其他工作。

那么问题的关键在哪里呢？就在上段的加粗字体：不需要的数据。JS如何判定该数据是不是我们需要的呢？

这个问题，红宝书里给出了两大判定方法：

* 标记清理(常用)：垃圾回收程序在每一轮清理前会标记所有的变量。程序执行的时候会动态地读取当前的上下文，当前上下文中的所有变量的标记都会被清理。于是剩下的变量就是当前上下文中不需要的变量，此时垃圾回收程序就会将它从内存当中清理出去。
* 引用计数（不常用）：垃圾回收程序会对所有的变量进行引用次数的统计。当一个对象的引用次数为0时，证明哪里都不能再访问它了，则将它销毁以释放内存。但是引用计数存在一个巨大的bug：当两个对象互相引用时，他们的标记数都不能被清0。

```javascript
// JS里的循环引用
// 新写一个构造函数
function Person(name){
    this.name = name
}
Person.prototype.constructor = Person // 此时你会发现Person的prototype属性引用了它的
// 原型对象，它的原型对象的constructor属性引用了Person。即Person和它的原型对象在互相引用。
// 要是你还不清楚什么是prototype和constructor，你只需把它们分别替换为a和b即可。
// 这种互相引用的情况在书里还举了DOM里的例子，所以引用计数现在基本已经不被使用了。
```



## _本章需要你掌握的问题：_

1. 解释一下JS里的按值传递？
2. 解释一下深拷贝和浅拷贝？
3. 进阶：手写一个深拷贝函数，可以返回数组或者对象的深拷贝?
