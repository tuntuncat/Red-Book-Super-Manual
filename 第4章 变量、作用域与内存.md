---
description: 'KEYWORDS: 原始值，引用值，深拷贝和浅拷贝，执行上下文，作用域，垃圾回收，内存优化'
cover: .gitbook/assets/javascript-736400-1.png
coverY: 0
---

# 第4章 变量、作用域与内存

## **4.1 原始值和引用值**

因为JS属于弱类型语言，所以JS的变量类型是不定的。

这是一把双刃剑，增加了便利性，消减了可维护性。或者换句话说，"前期编程爽，维护XX场"。所以当代大型前端项目都要实现TS(TypeScript)化，因为没有类型约束的项目终究走不长远。

JS里的数据只有两个大类型：**原始值**和**引用值**。

* 原始值：Number,String,Symbol,Undefined,Null,Boolean这6大类型都是原始值。
* 引用值：所有的对象，因为JS不允许直接操作对象所在的内存空间，所以引用值实际上是这些对象在内存的地址而非这些对象本身。

而在JS中，变量之间的数据传递书上说的不按“引用传递”，都是“按值传递”。实际上可能是翻译的问题，这里的“引用”指的就是对象本身，但是我们通常理解的“引用”是指的对象的地址（其实我们把JS里对象的值理解为对象的地址就好了，那么所有传递都是按值传递没有问题）。所以我们把书里的“值”实际上分为两种情况：

* 第一种情况是：如果某变量是原始类型，那么它就直接传递该值给其他变量。传递过后两个变量没有任何关系，可以独立操作。
* 第二种情况是：如果变量是引用类型，那么它就直接传递该对象的地址给其他变量（因为本身该变量的值就是对象的地址，所以这也是该变量的值）。所以单纯的传递地址会让多个变量指向同一个对象。

```javascript
const a = 1 // 值是一个原始类型
const b = a // a将值传递给b，所以b的值是1
const c = {} // 值是一个引用类型
const d = c // c将值传递给d，该值是一个地址，所以d是对象的地址
d.name = 'tuntun'
c.name // 'tuntun' 
```

第一种情况比较好理解，主要是第二种情况有时候不注意的话会出意料之外的情况，特别是在某些函数以引用值为参数时。

```javascript
function setName(obj){
// 这个obj实际上是函数内部作用域的局部变量
  obj.name = "Nicholas";
  // obj被指向了一个新对象 
  obj = new Object(); 
  obj.name = "Greg";
  return obj // 此时返回的是name为Greg的对象的引用，而非你传进来的引用了   
}
// 这是书中的例子，其实我们最关键的就是要理解obj实际上是我们在函数内部声明的一个新变量。
// 该变量指向外部传进的对象的地址，并且该指向在函数内部被修改了。
```

所以我们只需记住一句话：<mark style="color:red;">JS里的对象我们只能通过引用来操作(因为没有引用的对象都被销毁了。。。)</mark>。所以任何关于对象的读写，我们只需<mark style="color:red;">把对象本身和该对象的引用分开理解</mark>，就不会造成意外情况。

以上问题也引申出了一个大问题，**我们怎么复制对象而不是复制对象的引用**？

在任何面向对象的语言中，都会有一个经典问题：**怎么实现深拷贝和浅拷贝**？

* 浅拷贝：被拷贝对象内部含有引用类型，此时就不再拷贝引用类型的内容，而是拷贝引用就OK了
* 深拷贝：将被拷贝对象内部嵌套的引用类型完全拷贝下来。

```javascript
const a = [1,[2,3,[4,5]]
// 我们怎么深拷贝这个数组?
// 方法1
function copy(a){
 const b = []
 for(let i = 0; i < a.length; i++){
    b[i] = a[i]
 }
 return b   
}
b = copy(a) // [1,[2,3,[4,5]] , 虽然看起来一样，但是只完成了浅拷贝,里面的嵌套数组指向了同一个数组
// 方法2
function deepCopy(a){
   const newArray = []
   for(let i = 0; i < a.length; i++){
      if(typeof a[i] === 'object') { // 如果想精确一点，可以使用第3章里的Object.prototype.toString()
         // 此时我们需要递归地获取该二级数组
         newArray[i] = deepCopy(a[i])
      } else {
         newArray[i] = a[i]
      }
   }
   return newArray
}

// 另外，我们怎么深拷贝一个对象呢。涉及到两个问题：1 如何遍历一个对象的key 2 如何在key指向一个
// 嵌套对象的情况下继续深入拷贝
function deepCopyObj(obj) {
   const newObj = {}
   // 使用for-in 遍历, 这样的可以拷贝obj的可遍历属性
   // 还可以使用Object.entries(obj)来获取obj的key,value
   for(let key in obj){
         newObj[key] = typeof obj[key] !== ('object' || 'function') ? deepCopyObj(obj[key]) : obj[key] 
   }
   return newObj
}
// 测试一下
const a = {a:1 ,b:{c:1,d:{e:5}}}
const b = deepCopyObj(a)
console.log(b.b === a.b) // false，证明深拷贝成功了

// 我们可以发现两个方法实际上结构都类似，我们可以合并一下，是参数既可以是数组也可以是对象
function deepCopy(obj) {
    // 先判断obj的类型,使用instanceof 来判断会更精准一点
    const a = obj instanceof Array ? [] : {}
    // 使用ES2017新API Object.entries()遍历obj
    // [key,value]是ES6引入的解构赋值
    for([key,value] of Object.entries(obj)) {
       a[key] = typeof value === ('object' || 'function') ? deepCopyObj(value) : value
    }
    return a
}
// 测试一下
const a = [1,2,3,[4,5,6,{a:1,b:2}]]
const b = deepCopyObj(a)
console.log(b) // [1,2,3,[4,5,6,{a:1,b:2}]]
console.log(b[3][3] === a[3][3])  // false 这两个嵌套引用不指向同一个对象了
```

## 4.2 执行上下文、作用域链、标识符查找(3)

我们在JS中常听的两个词：执行上下文（context）/ 作用域（scope）。那么它们的区别到底是？

### 4.2.1 执行上下文

执行上下文实际上对应的是代码执行时的变量对象(variable object)，该对象存储了当前执行上下文的变量，函数，this，换句话说，执行上下文确定了当前程序的语境。

JS中共有三种执行上下文\[1]：

* 全局执行上下文：所有上下文共用的顶级上下文。不在任何函数中的代码都位于全局执行上下文中，它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。
* 函数执行上下文：每次调用函数时，都会为该函数创建一个新的执行上下文。
* eval执行上下文：eval 运行外部注入的JS代码也会创建自己的上下文。（极少涉及）

上下文在JS中被实例化为一个栈（执行上下文/调用栈）：当进入创建阶段时，新的上下文入栈。当执行完毕，当前上下文出栈，回到原来的上下文中。

![](https://pic3.zhimg.com/v2-336a4d2ab4ceeed94898edccf0d81072\_b.webp)

每个执行上下文具有三个生命周期：**创建阶段 → 执行阶段 → 回收阶段**

**创建阶段**：

* 创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。
* 创建作用域(Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。所以我们<mark style="color:red;">**所提的“作用域”实际上是在执行上下文的创建阶段，为上下文中的所有变量创立的一个标识符查找范围，它只是执行上下文创建过程中的一个子对象而已。**</mark>
* 确定 this 指向：确定当前上下文中的this指向的对象。例如为何我们在全局下能使用this.console对象，因为this指向了global(window)，同global.console。

![](<.gitbook/assets/image (3) (1) (1) (1).png>)

**执行阶段**：执行代码，如果进入新的函数，那么就将该函数执行上下文推入栈中。

**回收阶段**：当前上下文的代码执行完毕，上下文栈弹出当前上下文，重新回到上一级上下文中。

从上文也可知，当前的上下文总是在不停的切换之中的（实际就是栈顶元素不断被替换）。并且上下文始终是执行时才能确定。定义函数时你定义不了上下文，因为你不知道该函数是在怎样的情况下被调用。

### 4.2.2 作用域链

对于作用域链，我们访问变量也遵循这样的现象：例如你要访问a变量，那么JS引擎做的第一件事就是搞清楚你要访问哪里的a（因为你的代码可能有多个作用域，每个作用域都有a），那么查找该变量的顺序就形成了作用域链。再举个例子：你坐在电脑前，想找你的耳机。你查找的顺序通常是：先摸裤兜，再看桌面，要是桌面没有。你会看房间的其他位置，例如床上，枕头边啥的。要是你的房间再没有，你就会去你的客厅，餐桌上上找。你发现规律了吗：**查找满足就近原则**，找不到再去远处,找到了就不再继续找了。那么JS的作用域链也满足该条件。

还有一个特点，就是**查找只能从当前最近作用域往外找，不能往里找**。就像你没钱了，你可以找你爸要，你爸不给就找你爷爷要，但是你一般不会找你儿子要（要是你儿子是马云，随便要）。

在JS中，我们常用有三个作用域：**全局作用域，函数作用域，块作用域**(因为在for循环中实际上小括号里也是一个作用域)。全局作用域是最上层的唯一的作用域，函数/块作用域可以互相嵌套。

在执行上下文的创建阶段中，作用域链会被实例化为一个你无法访问的对象\[\[Scopes]]。JS引擎在执行代码时，首先会确定当前最近的作用域。

例如下图中你在全局下创建了一个函数（如果你不知道箭头函数，你把()=>{}当成function a(){}就行了），那么该函数最近的作用域就是全局作用域下。\[\[Scopes]]只有一个对象，那么就是全局作用域对象Global。

![](<.gitbook/assets/image (1) (1).png>)

如果你手动创建了一个块级作用域，并声明一个了局部变量。并在里面再声明一个函数。

![](<.gitbook/assets/image (1) (1) (1) (1).png>)

可以看到\[\[Scopes]]有两个对象了，第一个是一个Block(块作用域)对象，里面只有一个属性，就是你定义的块级变量b。

程序执行时，当前的\[\[Scopes]]会随着代码执行作用域的切换而切换。其实这个\[\[Scopes]]本质是一个栈，只能从一端进出。当栈顶找不到你想要的变量时，会弹出栈顶元素，继续查找栈顶，直到全局作用域被弹出。栈空了还找不到，那么就要报Referrence Error了。

学习作用域要联系第3章的变量声明说明：[#3.1.1-bian-liang-sheng-ming](<第3章 语言基础.md#3.1.1-bian-liang-sheng-ming> "mention"), 主要是熟悉TDZ，声明提前等特性。

我们再来看几个例子：

```javascript
const a = 1  // 全局下声明了一个a a1
for(let a = 1; a < 5; a++){ // 在for内实际声明了一个局部的a只用于迭代 a2
    let a = 2   // 块作用域下的a a3
    while(a) { // a3
        let a = 1 // 块作用域a4
        a-- // a4
    }
    console.log(a)
}
console.log(a)
// 请问执行这一段，会输出什么？
//                                                                         答案是： 什么都不会输出，无限循环，因为作用域链的存在，最内层的while里的a不会减少。因为这个a是a3
```

```javascript
const a = 1
f()
function f(){
    console.log(a)
    if(false){
        var a = 2
    }
}
// console的输出是？
//                                                                            答案是： undefined
// 因为var会在函数作用域里生效,且var自带声明提前，所以会在f执行前先在内部声明了a。
// 不要觉得if里的代码没执行就没用，在执行之前JS引擎会先解析一遍代码，并将var里的变量提前到当前作用域的最前方。
// 根据就近查找原则，那么f执行时会先在自己的作用域里查看有没有声明的a，在头部就查找到了a，直接就返回了，此时a还没有赋值

```

```javascript
const a = 1
f()
function f(){
    console.log(a)
    if(true){
        let a = 2
    }
}
// console的输出是？
//                                                                              答案是：1
// let没有声明提前了，所以在f内部没有声明的a，只能向外找到全局下的a。
```

上面两个例子也凸显了var的迷惑，以后大家就对var说再见吧。

## 4.3 垃圾回收

### 4.3.1 垃圾回收原理

前面说过，JS中我们无法直接操作内存里的对象（不像C++），直白地说就是我们无法直接对内存进行读写, 都是JS引擎代理了我们的操作。那么我们如果创建的对象，函数，变量不再使用了，为了避免内存泄漏，JS引擎就会负责把我们**不需要的数据**清理掉以腾出内存完成其他工作。

那么问题的关键在哪里呢？就在上段的加粗字体：不需要的数据。JS如何判定该数据是不是我们需要的呢？

这个问题，红宝书里给出了两大判定方法：

* 标记清理(常用)：垃圾回收程序在每一轮清理前会标记所有的变量。程序执行的时候会动态地读取当前的上下文，当前上下文中的所有变量的标记都会被清理。于是剩下的变量就是当前上下文中不需要的变量，此时垃圾回收程序就会将它从内存当中清理出去。
* 引用计数（不常用）：垃圾回收程序会对所有的变量进行引用次数的统计。当一个对象的引用次数为0时，证明哪里都不能再访问它了，则将它销毁以释放内存。但是引用计数存在一个巨大的bug：当两个对象互相引用时，他们的标记数都不能被清0。

```javascript
// JS里的循环引用
// 新写一个构造函数
function Person(name){
    this.name = name
}
Person.prototype.constructor === Person // true  此时你会发现Person的prototype属性引用了它的
// 原型对象，它的原型对象的constructor属性引用了Person。即Person和它的原型对象在互相引用。
// 要是你还不清楚什么是prototype和constructor，你只需把它们分别替换为a和b即可。
// 这种互相引用的情况在书里还举了DOM里的例子，所以引用计数现在基本已经不被使用了。
```

### 4.3.2 垃圾回收与性能之间的关系

垃圾回收虽然是为了优化性能而生的，但是其本身在工作期间也会消耗性能。当每次它清理的垃圾优化的性能比自己工作消耗的性能还小的化，证明这次工作是不划算的。

书中也介绍了IE7以前垃圾回收程序的清理频率是静态的（当变量占用的内存达到某一个固定阈值时就一直清理），这导致很多时候它白白占用了资源。

后面经过优化，垃圾回收程序会对回收的内存和全部分配的内存进行一个比例计算。当这个比例较低（15%以下）时，下次垃圾回收启动的阈值就会提高一倍（相当于降低了清理的频率）。当比例较高（85%以上）时，会还原到初始的较低的阈值。这样的动态调整极大得优化了垃圾回收的性能消耗。

## 4.4 内存管理

系统中一般浏览器分配的资源都不如桌面应用，因为浏览器会获取大量的外部数据，安全起见系统害怕运行大量的外部JS程序导致系统内存溢出而崩溃。所以引出了我们前端优化的一项巨大课题：内存优化。

对于内存优化，红包书中主要给出了以下几种方法:

* **手动解除全局对象的引用**：不是全局对象的可以不管，因为上下文的切换会让垃圾回收程序自动清理这类对象。但是全局对象作为所有作用域共用的顶级作用域，里面的对象在不显式地手动清理引用的情况下，会一直被保存在内存中。所以，如果全局作用域下的废弃对象，需要你手动解除对它的引用。让它在下一次的垃圾回收中被清理。

```javascript
let a = {name:'Ben'} // 声明一个全局对象a
const b = {name:a.name} //  声明一个对象b，使用了a的name
// 如果我们不再使用a了
a = null // 手动解除a对原来对象的引用
```

* **使用let和const而不是var**: var再一次被拿出来鞭尸。因为let和const都以块为作用域（细粒度更高），而var以函数和全局作为作用域（细粒度更低）。所以上下文切换对于let和const声明的变量来说更容易被清理标记，也就更容易被回收。用人话说，就是let和const声明的变量管的窄，被大范围引用的概率很低，但是var不一样，var声明的变量搞不好就是个全局变量,从创建可以一直占用内存到你关闭网页。
* **在构造函数创建的对象中尽量避免动态添加和删除属性**:JS V8引擎对于同一个构造函数创建的对象会创建一个隐藏类让它们共享该类的属性，但是如果你动态地添加或删除了实例的属性，将创建一个新的隐藏类,新隐藏类将会占用更多的内存。所以建议大家在构造函数实例化时，尽量先完全创建需要的属性,暂时没有值的设置为0或者null都可。

```javascript
function Cat(name, age){
    this.name = name
    this.age = age
}
const cat_1 = new Cat('tuntun', 1)
const cat_2 = new Cat('tutu', 0.5)
// 我们尽量要避免往cat_1,cat_2中动态添加属性
cat_1.food = 'fish' // 不推荐
function Cat(name, age){
    this.name = name
    this.age = age
    this.food = null // 推荐，后面再添加
}
// 我们也要避免cat_1,cat_2中动态删除属性
delete cat_1.age  // 不推荐
cat_1.age = null // 删除属性建议采取直接指向null的方式
```

* **谨慎使用闭包**（要是你不知道闭包也可以先跳过）：因为闭包会导致外部函数的变量因为内部函数执行而一直被引用。试想以下如果你的外部函数里声明了一个巨长无比的字符串，内部函数又恰巧需要运行很长的时间，那么这将是一场内存泄漏的灾难。
* **内存的静态分配**（这属于极少数情况下才会用到的优化）：这一节简单来说就是让你在创建对象和数组前尽量先分配好它们所占用的空间。对于对象来说，尽量避免短时间内创建大量的新对象或者临时对象，这会出发垃圾回收频繁工作。对于数组来说，尽量在一开始就分配好数组的长度，而不是动态地向里push新元素，因为这会导致JS频繁申请变更数组占用的内存，从而垃圾回收频繁工作。这类优化说实话已经属于优化界的“卷王”级优化，所以一般不考虑。

## _本章需要你掌握的问题_

1. 解释一下JS里的按值传递？
2. 解释一下深拷贝和浅拷贝？
3. 进阶：手写一个拷贝函数，可以返回数组或者对象的深拷贝?
4. 什么是作用域链，作用域链？什么是执行上下文？它们的关系是什么？
5. JS引擎常用的垃圾回收方法？
6. 为什么我们要尽量避免声明全局变量？
7. 列举几种常用的内存优化方法？

#### 参考文献：

\[1] [https://zhuanlan.zhihu.com/p/59784952](https://zhuanlan.zhihu.com/p/59784952), Fundebug
