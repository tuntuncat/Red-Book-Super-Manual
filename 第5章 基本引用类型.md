---
cover: .gitbook/assets/javascript-736400-1.png
coverY: 0
description: KEYWORDS：
---

# 第5章 基本引用类型

基本引用类型就是JS里的**标准内置对象**。

首先我们要明确标准内置对象的含义：**无需你定义即可在任何地方访问的对象（构造器），包括他们的方法和属性**。对于某些内置对象，我们既可以把它作为构造函数来创建一个对象的实例(例如new Date())，也可以使用该内置对象的静态方法来完成其他操作(例如Date.now())。

红宝书里这一章只花了最开始的一小部分来介绍JS里标准内置对象的一些特性，例如：

* JS里没有真正意义上的类（ES6引入的Class只能算是利用JS原型链模拟的类，不算真正的类）
* 引用类型和对象实例之间是构造器和被构造对象的关系
* 我们通常使用"new 构造函数()"的方式来创建一个只有默认属性和方法的简单对象

但是在红宝书的这一章里，除了最前面这一小节，其他的篇幅总的来说就介绍了几种内置标准对象：Date，RegExp，String，Boolean，Number。

不知道红宝书作者为何要如此编排，把Date作为第一个大家见到的内置对象，就会让很多刚刚学习JS的人认为Date是很重要的一种类型。但是Date里面巨多无比又难以记忆的方法不知道劝退了多少人。

现在我看来以Date自身的重要性来看远远没有必要放在这个章节的第一节, 也没有必要专门深入讲解Date里的各种方法，而且关于其他内置对象的介绍又真的太少了，所以我去查了MDN的《标准内置对象》：

[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects#%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB)

MDN里面对于JS里的内置对象分类非常全面。所以我建议大家学习这部分，不要参考红宝书里的章节排布，而是参考上面的链接。另外，建议读者在学习各种基本引用类型的时候不要太依赖于书籍，最好是自己去查一查官方文档，动手去试一试里面的对象和方法到底有什么用。那么在超级手册当中，就基于MDN里的分类（MDN里的分类也是一言难尽），自己稍微修改了一下使得更加便于记忆。这一章也主要是简介这些基本内置对象，如果全部要展开说，那么超级手册就变成超级API文档了，所以关于这些对象的具体属性和方法就不在本章中深入了。

## 5.1 对象分类

### 5.1.1 全局对象 - Global

全局对象就是ES里定义的global对象，在浏览器里被实现为window对象。其实全局能直接（不通过其他对象间接访问）访问到的值和函数，就是我们的顶层对象global的值和方法。因为在非严格模式下，全局上下文的this指向window。

![](<.gitbook/assets/image (2) (1).png>)

### 5.1.2 基本对象 - Object、Symbol

JS里又把以下基本引用类型放入了基本对象当中，也就是JS里最最最常用的对象。

在MDN中，Boolean和Symbol因为无法归入后面的“字符串对象”，“数字对象”，所以被归入了基本对象，但是很明显，他俩跟Object和Function来比远远不够“基本”。所以我做了一些修改，在基本对象中剔除了Boolean和Symbol，使它们自成一类。

### 5.1.3 错误对象 - Error

我们平时跑程序抛出的错误都是对象。以下就是JS里给你预设好的一些错误对象。

| 对象名            | 对象含义         | 备注                               |
| -------------- | ------------ | -------------------------------- |
| Error          | 最一般的错误对象     | 其他的所有错误对象都继承该对象                  |
| AggregateError | 表示一个复合型的错误   | 尚在实验当中                           |
| EvalError      | 由eval()抛出的错误 | 现在已不会被JS抛出                       |
| InternalError  | JS引擎内部错误     | 如果你的递归函数没有设置递归的结束条件，那么很有可能会抛出此错误 |
| RangeError     | 范围错误         |                                  |
| ReferenceError | 引用错误         | 在当前的执行上下文里没有找到引用的标识符             |
| SyntaxError    | 语法错误         | 代码出现了不该出现的字符，例如多了一个,{，）之类的字符     |
| TypeError      | 类型错误         | 值类型非预期类型时抛出的错误                   |
| URIError       | URI错误        | 向URI处理函数传递不合法URI时的错误             |

那这些对象很明显不只是JS引擎抛给你，你自己也可以使用try catch来捕获你自己抛出的错误实例。毕竟，以上的对象本身都是构造器，都是可以传参进去然后返回给你一个错误对象的。我们以Error来举一个例子。

```javascript
const e = new Error('this is an error made by tuntuncat') // 创建一个错误实例e

// 使用try catch测试一下
try{
    if(false) { // if是你的判断错误条件
        throw e
    }
} catch(e) {
    console.log(e.message)
} // this is an error made by tuntuncat
```

e会继承Error原型上的所有对象和方法。

![](<.gitbook/assets/image (3) (1).png>)

另外所有的次级Error对象都继承了Error:

![](<.gitbook/assets/image (1).png>)

### 5.1.4 数字、数学对象 - Number、BigInt、Math

数字除了用基本类型来直接表示，也可以使用标准内置对象来生成。以下是JS内置的跟数字相关的标准内置对象:

| 对象名    | 对象含义               | 备注                       |
| ------ | ------------------ | ------------------------ |
| Number | 最基础的数字对象           | 生成的对象是IEEE 754 64位的浮点数类型 |
| BigInt | 大于JS所能精确存储的最大数字的数字 | 生成大数字实例可以与大数字之间进行四则运算    |
| Math   | 基础的数学对象生成器         | Math不是构造器，只能使用它的静态属性和方法  |

![Math is not a constructor](.gitbook/assets/image.png)

Math不是一个构造器，所以不能使用new关键字。

关于BigInt可以回到[#3.1.2-shu-ju-lei-xing-3](<第3章 语言基础.md#3.1.2-shu-ju-lei-xing-3> "mention")里再看下。

### 5.1.5 日期对象 - Date

JS里为了方便开发者使用时间作为参数，专门提供了日期内置对象。

日期类的对象只有一个: Date(不是约会)。

下面举例Date对象的几个基本用法：

* **记录程序运行时间**

```javascript
const start = new Date()
for(let i = 0; i < 10000000; i++) {
}
const end = new Date()
console.log(end - start + 'ms') // 9ms 该方法只对同步任务有效，异步任务无效
```

* **将某时间转换成本地时间字符串表示**

```javascript
const date = new Date(Date.UTC(2021, 11, 19, 3, 0, 0)) // UTC世界协调时
console.log(date.toLocaleString()) // 不传入参数时默认使用本地时区和语言
// → '2021/12/19 上午11:00:00' // 北京比0时区早8个小时
```

![关于世界协调时可以参考上图，北京在+8时区，0时刻应该是在0经度线上。](https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/World\_Time\_Zones\_Map.png/1920px-World\_Time\_Zones\_Map.png)

### 5.1.6 布尔对象 - Boolean

在[#3-bu-er-cao-zuo-fu](<第3章 语言基础.md#3-bu-er-cao-zuo-fu> "mention")里，介绍了JS的真值和假值。那么我们给Boolean对象包装器传入假值时，就会返回一个原始值(primitive value)为false的对象，真值反之亦然。既然是对象，那么它就比原始类型值要强大的多。

Boolean对象是一个布尔值的对象包装器。因为在JS里还存在Boolean原始类型值，所以容易与Boolean对象实例混淆。但是混淆了也没事，因为JS引擎在背后让我们基本体会不到它们之间的差异。

![](<.gitbook/assets/image (3).png>)

上图中，我们声明了一个a变量，指向一个Boolean对象。可以看出该Boolean对象的原始值是false，toString方法就是将原始值false转为字符串"false"。但是疑问来了，我们又声明了一个变量，值为原始值false，但是依然可以调用相关的方法。不是只有对象才能调用方法吗？

其实，当我们调用某包装对象方法时，JS会自动将该变量传入相应类型的对象包装器中（生成的对象实例也被称为包装对象），以方便我们调用方法。在调用某方法得到返回结果后，该包装对象将被销毁(因为实际上该对象没有引用，会被垃圾回收程序销毁)，或者说我们只是使用了对象上的某方法，将其作为一个立即执行函数(Immediately-Invoked Function Expression，IIFE)调用获得返回值而已。整个过程都是在后台执行，所以从这个角度上说，基本类型也能调用方法。

但是事情没有那么简单，在1作为一个原始值出现的时候，你直接调用会抛出语法错误。但是true就可以直接调用，为什么1不行呢？

![](<.gitbook/assets/image (6).png>)

眼尖的同学发现没有，在1后面的小数点是蓝色的，true后面的小数点是黑色的。在chrome控制台里，蓝色的代表数字值，黑色的代表语法符号（例如, .\[]\(){}等）或者标识符(a $ \_等)。那么蓝色的点其实代表在JS引擎解析时，把这个点当做了小数点，即相当于将"1."作为了一个数字整体。那么我们平时调用方法时使用的"." ,不应该是小数点而应该是访问对象方法的"点语法",所以在上图中相当于引擎压根儿没有使用"点语法"。针对这个错误，我们来尝试一下解决这个问题。

![](<.gitbook/assets/image (7).png>)

我们将"1."作为一个整体，然后再加一个"."。后面这个点就是黑色的，此时才表示我们使用了"点语法"。或者我们直接给1加一个括号让"."与1隔开，这样引擎才能正确理解我们的意图。

### 5.1.7 符号对象 - Symbol
