---
cover: .gitbook/assets/javascript-736400-1.png
coverY: 0
description: KEYWORDS：标准内置对象，构造器，包装器
---

# 第5章 基本引用类型

基本引用类型就是JS里的**标准内置对象**。

首先我们要明确标准内置对象的含义：**无需你定义即可在任何地方访问的对象（构造器），包括他们的方法和属性**。对于某些内置对象，我们既可以把它作为构造函数来创建一个对象的实例(例如new Date())，也可以使用该内置对象的静态方法来完成其他操作(例如Date.now())。

红宝书里这一章只花了最开始的一小部分来介绍JS里标准内置对象的一些特性，例如：

* JS里没有真正意义上的类（ES6引入的Class只能算是利用JS原型链模拟的类，不算真正的类）
* 引用类型和对象实例之间是构造器和被构造对象的关系
* 我们通常使用"new 构造函数()"的方式来创建一个只有默认属性和方法的简单对象

但是在红宝书的这一章里，除了最前面这一小节，其他的篇幅总的来说就介绍了几种内置标准对象：Date，RegExp，String，Boolean，Number。

不知道红宝书作者为何要如此编排，把Date作为第一个大家见到的内置对象，就会让很多刚刚学习JS的人认为Date是很重要的一种类型。但是Date里面巨多无比又难以记忆的方法不知道劝退了多少人。

现在我看来以Date自身的重要性来看远远没有必要放在这个章节的第一节, 也没有必要专门深入讲解Date里的各种方法，而且关于其他内置对象的介绍又真的太少了，所以我去查了MDN的《标准内置对象》：

[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects#%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB)

MDN里面对于JS里的内置对象分类非常全面。所以我建议大家学习这部分，不要参考红宝书里的章节排布，而是参考上面的链接。另外，建议读者在学习各种基本引用类型的时候不要太依赖于书籍，最好是自己去查一查官方文档，动手去试一试里面的对象和方法到底有什么用。那么在超级手册当中，就基于MDN里的分类（MDN里的分类也是一言难尽），自己稍微修改了一下使得更加便于记忆。这一章也主要是简介这些基本内置对象，如果全部要展开说，那么超级手册就变成超级API文档了，所以关于这些对象的具体属性和方法就不在本章中深入了（如果前面的章节有的我会贴出链接）。

## 5.1 对象分类

### 5.1.1 全局对象 - Global

全局对象就是ES里定义的global对象，在浏览器里被实现为window对象。其实全局能直接（不通过其他对象间接访问）访问到的值和函数，就是我们的顶层对象global的值和方法。因为在非严格模式下，全局上下文的this指向window。

![](<.gitbook/assets/image (2) (1) (1) (1).png>)

### 5.1.2 基本对象 - Object

JS里又把以下基本引用类型放入了基本对象当中，也就是JS里最最最常用的对象。

在MDN中，Boolean和Symbol因为无法归入后面的“字符串对象”，“数字对象”，所以被归入了基本对象，但是很明显，他俩跟Object和Function来比远远不够“基本”。所以我做了一些修改，在基本对象中剔除了Boolean和Symbol，使它们自成一类。

Object在[#6.1-object](di-6-zhang-ji-he-yin-yong-lei-xing.md#6.1-object "mention")里有详细解释。

### 5.1.3 错误对象 - Error

我们平时跑程序抛出的错误都是对象。以下就是JS里给你预设好的一些错误对象。

| 对象名            | 对象含义         | 备注                               |
| -------------- | ------------ | -------------------------------- |
| Error          | 最一般的错误对象     | 其他的所有错误对象都继承该对象                  |
| AggregateError | 表示一个复合型的错误   | 尚在实验当中                           |
| EvalError      | 由eval()抛出的错误 | 现在已不会被JS抛出                       |
| InternalError  | JS引擎内部错误     | 如果你的递归函数没有设置递归的结束条件，那么很有可能会抛出此错误 |
| RangeError     | 范围错误         |                                  |
| ReferenceError | 引用错误         | 在当前的执行上下文里没有找到引用的标识符             |
| SyntaxError    | 语法错误         | 代码出现了不该出现的字符，例如多了一个,{，）之类的字符     |
| TypeError      | 类型错误         | 值类型非预期类型时抛出的错误                   |
| URIError       | URI错误        | 向URI处理函数传递不合法URI时的错误             |

那这些对象很明显不只是JS引擎抛给你，你自己也可以使用try catch来捕获你自己抛出的错误实例。毕竟，以上的对象本身都是构造器，都是可以传参进去然后返回给你一个错误对象的。我们以Error来举一个例子。

```javascript
const e = new Error('this is an error made by tuntuncat') // 创建一个错误实例e

// 使用try catch测试一下
try{
    if(false) { // if是你的判断错误条件
        throw e
    }
} catch(e) {
    console.log(e.message)
} // this is an error made by tuntuncat
```

e会继承Error原型上的所有对象和方法。

![](<.gitbook/assets/image (3) (1) (1).png>)

另外所有的次级Error对象都继承了Error:

![](<.gitbook/assets/image (1).png>)

### 5.1.4 数字、数学对象 - Number、BigInt、Math

数字除了用基本类型来直接表示，也可以使用标准内置对象来生成。以下是JS内置的跟数字相关的标准内置对象:

| 对象名    | 对象含义               | 备注                       |
| ------ | ------------------ | ------------------------ |
| Number | 最基础的数字对象           | 生成的对象是IEEE 754 64位的浮点数类型 |
| BigInt | 大于JS所能精确存储的最大数字的数字 | 生成大数字实例可以与大数字之间进行四则运算    |
| Math   | 基础的数学对象生成器         | Math不是构造器，只能使用它的静态属性和方法  |

![Math is not a constructor](.gitbook/assets/image.png)

Math不是一个构造器，所以不能使用new关键字。

关于BigInt可以回到[#3.1.2-shu-ju-lei-xing-3](<第3章 语言基础.md#3.1.2-shu-ju-lei-xing-3> "mention")里再看下。

### 5.1.5 日期对象 - Date

JS里为了方便开发者使用时间作为参数，专门提供了日期内置对象。

日期类的对象只有一个: Date(不是约会)。

下面举例Date对象的几个基本用法：

* **记录程序运行时间**

```javascript
const start = new Date()
for(let i = 0; i < 10000000; i++) {
}
const end = new Date()
console.log(end - start + 'ms') // 9ms 该方法只对同步任务有效，异步任务无效
```

* **将某时间转换成本地时间字符串表示**

```javascript
const date = new Date(Date.UTC(2021, 11, 19, 3, 0, 0)) // UTC世界协调时
console.log(date.toLocaleString()) // 不传入参数时默认使用本地时区和语言
// → '2021/12/19 上午11:00:00' // 北京比0时区早8个小时
```

![关于世界协调时可以参考上图，北京在+8时区，0时刻应该是在0经度线上。](https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/World\_Time\_Zones\_Map.png/1920px-World\_Time\_Zones\_Map.png)

PS: 当你想在你的项目里调用Date时，可以关注一下基于Date实现的第三方的更常用的库例如moment.js或者day.js。

### 5.1.6 布尔对象 - Boolean

在[#3-bu-er-cao-zuo-fu](<第3章 语言基础.md#3-bu-er-cao-zuo-fu> "mention")里，介绍了JS的真值和假值。那么我们给Boolean对象包装器传入假值时，就会返回一个原始值(primitive value)为false的对象，真值反之亦然。既然是对象，那么它就比原始类型值要强大的多。

Boolean对象是一个布尔值的对象包装器。因为在JS里还存在Boolean原始类型值，所以容易与Boolean对象实例混淆。但是混淆了也没事，因为JS引擎在背后让我们基本体会不到它们之间的差异。

![](<.gitbook/assets/image (3) (1).png>)

上图中，我们声明了一个a变量，指向一个Boolean对象。可以看出该Boolean对象的原始值是false，toString方法就是将原始值false转为字符串"false"。但是疑问来了，我们又声明了一个变量，值为原始值false，但是依然可以调用相关的方法。不是只有对象才能调用方法吗？

其实，当我们调用某包装对象方法时，JS会自动将该变量传入相应类型的对象包装器中（生成的对象实例也被称为包装对象），以方便我们调用方法。在调用某方法得到返回结果后，该包装对象将被销毁(因为实际上该对象没有引用，会被垃圾回收程序销毁)，或者说我们只是使用了对象上的某方法，将其作为一个立即执行函数(Immediately-Invoked Function Expression，IIFE)调用获得返回值而已。整个过程都是在后台执行，所以从这个角度上说，基本类型也能调用方法。

但是事情没有那么简单，在1作为一个原始值出现的时候，你直接调用会抛出语法错误。但是true就可以直接调用，为什么1不行呢？

![](<.gitbook/assets/image (6).png>)

眼尖的同学发现没有，在1后面的小数点是蓝色的，true后面的小数点是黑色的。在chrome控制台里，蓝色的代表数字值，黑色的代表语法符号（例如, .\[]\(){}等）或者标识符(a $ \_等)。那么蓝色的点其实代表在JS引擎解析时，把这个点当做了小数点，即相当于将"1."作为了一个数字整体。那么我们平时调用方法时使用的"." ,不应该是小数点而应该是访问对象方法的"点语法",所以在上图中相当于引擎压根儿没有使用"点语法"。针对这个错误，我们来尝试一下解决这个问题。

![](<.gitbook/assets/image (7).png>)

我们将"1."作为一个整体，然后再加一个"."。后面这个点就是黑色的，此时才表示我们使用了"点语法"。或者我们直接给1加一个括号让"."与1隔开，这样引擎才能正确理解我们的意图。

### 5.1.7 符号对象 - Symbol

symbol作为唯一的没有字面量的原始数据类型，只能通过Symbol函数来创建。通过Symbol函数创建的symbol是唯一的。

关于Symbol包装器，我们不能使用new关键字。因为Symbol()并不是完整的构造器。

关于Symbol的更多方法：参见[#3.2.2-shu-ju-lei-xing-ming-xi](<第3章 语言基础.md#3.2.2-shu-ju-lei-xing-ming-xi> "mention")里的symbol。

### 5.1.8 字符串对象 - String、RegExp

String对象用于将任何数据转换为字符串表示，RegExp用于创建正则表达式的实例。其实String是一种特殊的正则表达式，正则表达式是一种扩大了表达范围的字符串。

关于字符串实例方法，参见[#3.2.2-shu-ju-lei-xing-ming-xi](<第3章 语言基础.md#3.2.2-shu-ju-lei-xing-ming-xi> "mention")里的字符串一节。

正则表达式虽然有字面量表示方法，但是不属于JS里的原始数据类型。所以前面也没有更详细的介绍，但是我看了一下红宝书后面的章节也没讲。对于只看了红宝书学习JS的同学，如果没有在其他语言里学习过正则表达式，那么在这一方面的知识就会严重欠缺了，所以在本书中补充上。

#### 1）正则表达式的含义

正则表达式是一类字符串的表示方法，或者与文本的特定匹配模式。

#### 2）正则表达式的创建

* 与字符串一样，可以通过字面量方法创建&#x20;
* 使用RegExp包装器创建

```javascript
const a = /abc/gi // 字面量创建，斜杠内的内容就是我们的匹配内容，斜杠后的字母代表匹配的模式，匹配'abc'，全局查找，忽略大小写
const b = new RegExp('abc','gi') // 包装器，匹配'abc'，全局查找，忽略大小写
```

#### 3）正则表达式的常用匹配规则

正则实际上是非常强大的，所以要完全掌握也是需要花很多时间的。但是我们在日常使用中，常用的匹配规则也不是特别多，下面就尽量简要的介绍一下常用的匹配规则。

对于正则，我们可以从最基本的简单匹配来入门。

```javascript
const easy = /abc/ // 表示匹配'abc'的字符串
easy.test('abcd') // true 表示该字符串可以匹配该正则
easy.test('abdc') // false 不能匹配，因为不含有'abc'
```

但是简单匹配并不能完全满足我们的需求，如果我们需要匹配手机号码？电子邮箱？或者某些账号呢？难道我们把所有的手机号码都做成正则吗？所以正则需要能简单表示一类字符。

就像两个不重合点确定一根直线，平面上三个不共线点确定一个三角形。对于一类字符，我们首先需要确定的概念就是：我们如何精确定义一类字符？指标到底是什么？

那么正则表达式里，就通过4个指标来精确定义一类字符：

* 元字符: 即描述一类字符的特殊字符，通常由反斜杠\开头或者\[]里的字符
* 数量：即描述元字符表达式出现次数的指标
* 位置：即元字符表达式是否满足特定位置
* 匹配模式：对于输入字符串采取的匹配方式

简单来说就是**是什么，有多少，在哪里，怎么找**的问题。

**指标1 - 元字符\[1]**：

| 字符                   | 含义                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `.`                  | <p>（小数点）默认匹配除换行符之外的任何单个字符。</p><p>例如，<code>/.n/</code> 将会匹配 "nay, an apple is on the tree" 中的 'an' 和 'on'，但是不会匹配 'nay'。</p><p>如果 <code>s</code> ("dotAll") 标志位被设为 true，它也会匹配换行符。</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `[xyz]`              | <p>一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。<br>例如，[abcd] 和[a-d]是一样的。他们都匹配"brisket"中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\w.]+/与字符串“test.i.ng”匹配。</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `[^xyz]`             | <p>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。</p><p>例如，[^abc] 和 [^a-c] 是一样的。他们匹配"brisket"中的‘r’，也匹配“chop”中的‘h’。</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `[\b]`               | 匹配一个退格(U+0008)。（不要和\b混淆了。）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `\b`                 | <p>匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\b]混淆了）</p><p>使用"moon"举例：<br>/\bm/匹配“moon”中的‘m’；<br>/oo\b/并不匹配"moon"中的'oo'，因为'oo'被一个“字”字符'n'紧跟着。<br>/oon\b/匹配"moon"中的'oon'，因为'oon'是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。<br>/\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。</p>                                                                                                                                                                                                                                                                                                                                                               |
| `\B`                 | <p>匹配一个非单词边界。匹配如下几种情况：</p><ul><li>字符串第一个字符为非“字”字符</li><li>字符串最后一个字符为非“字”字符</li><li>两个单词字符之间</li><li>两个非单词字符之间</li><li>空字符串</li></ul><p>例如，/\B../匹配"noonday"中的'oo', 而/y\B../匹配"possibly yesterday"中的’yes‘</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `\c`_`X`_            | <p>当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。</p><p>例如，<code>/\cM/</code> 匹配字符串中的 control-M (U+000D)。</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `\d`                 | <p>匹配一个数字<code>。等价于[0-9]</code>。</p><p>例如， <code>/\d/</code> 或者 <code>/[0-9]/</code> 匹配"B2 is the suite number."中的'2'。</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `\D`                 | <p>匹配一个非数字字符<code>。等价于[^0-9]</code>。</p><p>例如， <code>/\D/</code> 或者 <code>/[^0-9]/</code> 匹配"B2 is the suite number."中的'B' 。</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| `\f`                 | 匹配一个换页符 (U+000C)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|  \n                  | 匹配一个换行符 (U+000A)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|  \r                  | 匹配一个回车符 (U+000D)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `\s`                 | <p>匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。</p><p>例如, <code>/\s\w*/</code> 匹配"foo bar."中的' bar'。</p><p>经测试，\s不匹配"\u180e"，在当前版本Chrome(v80.0.3987.122)和Firefox(76.0.1)控制台输入/\s/.test("\u180e")均返回false。</p>                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| `\S`                 | <p>匹配一个非空白字符。等价于 <code>[^</code> \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff<code>]</code>。</p><p>例如，<code>/\S\w*/</code> 匹配"foo bar."中的'foo'。</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|  \t                  | 匹配一个水平制表符 (U+0009)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `\v`                 | 匹配一个垂直制表符 (U+000B)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `\w`                 | <p>匹配一个单字字符（字母、数字或者下划线）。等价于 <code>[A-Za-z0-9_]</code>。</p><p>例如, <code>/\w/</code> 匹配 "apple," 中的 'a'，"$5.28,"中的 '5' 和 "3D." 中的 '3'。</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `\W`                 | <p>匹配一个非单字字符。等价于 <code>[^A-Za-z0-9_]</code>。</p><p>例如, <code>/\W/</code> 或者 <code>/[^A-Za-z0-9_]/</code> 匹配 "50%." 中的 '%'。</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `\`_`n`_             | <p>在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。</p><p>比如 <code>/apple(,)\sorange\1/</code> 匹配"apple, orange, cherry, peach."中的'apple, orange,' 。</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `\0`                 | 匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 `\0<digits>` 是一个八进制转义序列。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `\xhh`               | 匹配一个两位十六进制数（\x00-\xFF）表示的字符。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `\uhhhh`             | 匹配一个四位十六进制数表示的 UTF-16 代码单元。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `\u{hhhh}或\u{hhhhh}` | （仅当设置了u标志时）匹配一个十六进制数表示的 Unicode 字符。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `\`                  | <p>依照下列规则匹配：</p><p>在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 "\" 的 "b" 通常匹配小写字母 "b"，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 "\"，它将不再匹配任何字符，而是表示一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#note">字符边界</a>。</p><p>在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 "转义（Escaping）" 部分。</p><p>如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。<code>/[a-z]\s/i</code> 和 <code>new RegExp("[a-z]\\s", "i")</code> 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（<code>\s</code> 可看后文）并且在 a-z 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如 <code>/[a-z]:\\/i</code> 和 <code>new RegExp("[a-z]:\\\\","i")</code> 会创建相同的表达式，即匹配类似 "C:\" 字符串。</p> |
| `(x)`                | <p>像下面的例子展示的那样，它会匹配 'x' 并且记住匹配项。其中括号被称为<em>捕获括号</em>。</p><p>模式 <code>/(foo) (bar) \1 \2/</code> 中的 '<code>(foo)</code>' 和 '<code>(bar)</code>' 匹配并记住字符串 "foo bar foo bar" 中前两个单词。模式中的 <code>\1</code> 和 <code>\2</code> 表示第一个和第二个被捕获括号匹配的子字符串，即 <code>foo</code> 和 <code>bar</code>，匹配了原字符串中的后两个单词。注意 <code>\1</code>、<code>\2</code>、...、 是用在正则表达式的匹配环节，详情可以参阅后文的  条目。而在正则表达式的替换环节，则要使用像 <code>$1</code>、<code>$2</code>、...、<code>$n</code> 这样的语法，例如，<code>'bar foo'.replace(/(...) (...)/, '$2 $1')</code>。<code>$&#x26;</code> 表示整个用于匹配的原字符串。</p>                                                                                                                                                               |
| `x\|y`               | <p>匹配‘x’或者‘y’。</p><p>例如，/green|red/匹配“green apple”中的‘green’和“red apple”中的‘red’</p>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `(?:x)`              | 匹配 'x' 但是不记住匹配项。这种括号叫作_非捕获括号_，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 `/(?:foo){1,2}/`。如果表达式是 `/foo{1,2}/`，`{1,2}` 将只应用于 'foo' 的最后一个字符 'o'。如果使用非捕获括号，则 `{1,2}` 会应用于整个 'foo' 单词。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |

**指标2 - 数量:**

| 字符      | 含义                                                                                                                                                                                                                                                                                                                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `*`     | <p>匹配前一个表达式 0 次或多次。等价于 <code>{0,}</code>。</p><p>例如，<code>/bo*/</code> 会匹配 "A ghost boooooed" 中的 'booooo' 和 "A bird warbled" 中的 'b'，但是在 "A goat grunted" 中不会匹配任何内容。</p>                                                                                                                                                                                                                                                         |
| `+`     | <p>匹配前面一个表达式 1 次或者多次。等价于 <code>{1,}</code>。</p><p>例如，<code>/a+/</code> 会匹配 "candy" 中的 'a' 和 "caaaaaaandy" 中所有的 'a'，但是在 "cndy" 中不会匹配任何内容。</p>                                                                                                                                                                                                                                                                                   |
| `?`     | <p>匹配前面一个表达式 0 次或者 1 次。等价于 <code>{0,1}</code>。</p><p>例如，<code>/e?le?/</code> 匹配 "angel" 中的 'el'、"angle" 中的 'le' 以及 "oslo' 中的 'l'。</p><p>如果<strong>紧跟在任何量词 *、 +、? 或 {} 的后面</strong>，将会使量词变为<strong>非贪婪</strong>（匹配尽量少的字符），和缺省使用的<strong>贪婪模式</strong>（匹配尽可能多的字符）正好相反。例如，对 "123abc" 使用 <code>/\d+/</code> 将会匹配 "123"，而使用 <code>/\d+?/</code> 则只会匹配到 "1"。</p><p>还用于先行断言中，如本表的 <code>x(?=y)</code> 和 <code>x(?!y)</code> 条目所述。</p> |
| `{n}`   | <p>n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。<br>比如， /a{2}/ 不会匹配“candy”中的'a',但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个'a'。</p>                                                                                                                                                                                                                                                                                                                    |
| `{n,}`  | <p>n是一个正整数，匹配前一个字符至少出现了n次。</p><p>例如, /a{2,}/ 匹配 "aa", "aaaa" 和 "aaaaa" 但是不匹配 "a"。</p>                                                                                                                                                                                                                                                                                                                                          |
| `{n,m}` | <p>n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。</p><p>例如，/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中的a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。</p>                                                                                                                                                                                                                            |

**指标3 - 位置**：

| `^`          | <p>匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。</p><p>例如，<code>/^A/</code> 并不会匹配 "an A" 中的 'A'，但是会匹配 "An E" 中的 'A'。</p><p>当 '<code>^</code>' 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。</p>                                                  |
| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `$`          | <p>匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。</p><p>例如，<code>/t$/</code> 并不会匹配 "eater" 中的 't'，但是会匹配 "eat" 中的 't'。</p>                                                                                                            |
| `x(?=y)`     | <p>匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。</p><p>例如，/Jack(?=Sprat)/会匹配到'Jack'仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p>                                                    |
| `(?<=y)`x    | <p>匹配'x'仅当'x'前面是'y'.这种叫做后行断言。</p><p>例如，/(?&#x3C;=Jack)Sprat/会匹配到' Sprat '仅仅当它前面是' Jack '。/(?&#x3C;=Jack|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是'Jack'或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。</p>                                           |
| `x(?!y)`     | <p>仅仅当'x'后面不跟着'y'时匹配'x'，这被称为正向否定查找。</p><p>例如，仅仅当这个数字后面没有跟小数点的时候，/\d+(?!\.)/ 匹配一个数字。正则表达式/\d+(?!\.)/.exec("3.141")匹配‘141’而不是‘3.141’</p>                                                                                      |
| (?\<!_y_)_x_ | <p>仅仅当'x'前面不是'y'时匹配'x'，这被称为反向否定查找。</p><p>例如, 仅仅当这个数字前面没有负号的时候，<code>/(?&#x3C;!-)\d+/</code> 匹配一个数字。<br><code>/(?&#x3C;!-)\d+/.exec('3')</code> 匹配到 "3".<br><code>/(?&#x3C;!-)\d+/.exec('-3')</code> 因为这个数字前有负号，所以没有匹配到。</p> |

有了上面的基础，我们可以通过一些例子来加深印象\[2]：

```javascript
// 用户名验证: 4-16位数字，字母下划线，分隔符
const user = /^[a-zA-Z0-9_-]{4,16}$/ //如果不加^或者$，则字符串内部存在合格子串也会存在匹配项
user.test(username) // true或者false

// 密码验证： 最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
const password = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/

// 整数验证: 正整数，负整数
const positiveInt = /^\d+$/ // 正整数
const negtiveInt = /-^\d+$/ // 负整数
const int = /^[+-]?\d+$/ // 整数

// 浮点数验证
const float = /^\d*(.\d+)?$/

// Email验证
const email = /^\w+@[a-zA-Z0-9]+.[a-z]+(.[a-z]+)?$/

// ipv4验证
const ipv4 = /^((([0-9]|[1-9][0-9]|[1-2][0-5][0-5])\.){3}([0-9]|[1-9][0-9]|[1-2][0-5][0-5]){1})$/

// 包含中文验证
const hasChinese = /[\u4E00-\u9FA5]/
```

正则表达式的学习方式是手动测试，构造不同的测试用例来看你的正则是否具有良好的准确性和鲁棒性，然后根据结果再反馈优化你的正则表达式。

### 5.1.9  数组对象 - Array、TypedArray

Array是JS里最常用的内置对象之一，关于Array我们这里就不再赘述。

在ES6里引入了定型数组TypedArray，描述了一个底层的[二进制数据缓冲区](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/ArrayBuffer)（binary data buffer）的一个类数组视图（view）\[3]。表示数组内部的元素是限定大小范围的数字的数组，定型数组会在开始创建时就划分好内存缓冲区(Array Buffer)。定型数组内部读写都采用二进制存储和交换数据，所以读写的速度极快。

上面这段话主要有两个概念需要解释：

1. 二进制数据缓存区(Array Buffer)

&#x20;  可以形象地理解为一段连续的内存，里面的基本存储单元是一个字节(8bit)。Array  Buffer是不能被直接访问的，你只能借助数据视图(Data View)来访问。

&#x20; 2.类数组视图

&#x20;   视图(View)在这里的意思就是你解码Array Buffer的方式， 所以这里其实也可以理解为视角。Array Buffer上的元数据实际上都是一样的，只是我们可以换一个视角（View）来解读上面的数据。那么此时的“视图”就是视角的意思，跟“横看成岭侧成峰，远近高低各不同”异曲同工。

&#x20;   当我们使用类数组的视图来解码数据的时候，此时的视图也就成为了类数组视图。下表\[3]中所列的都是类数组视图，同时也是定型数组的构造函数。

| 类型                                                                                                                         | 单个元素值的范围                        | 大小(bytes) | 描述                                    |
| -------------------------------------------------------------------------------------------------------------------------- | ------------------------------- | --------- | ------------------------------------- |
| [`Int8Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Int8Array)                 | `-128` to `127`                 | 1         | 8 位二进制有符号整数                           |
| [`Uint8Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Uint8Array)               | `0` to `255`                    | 1         | 8 位无符号整数（超出范围后从另一边界循环）                |
| [`Uint8ClampedArray`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Uint8ClampedArray) | `0` to `255`                    | 1         | 8 位无符号整数（超出范围后为边界值）                   |
| [`Int16Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Int16Array)               | `-32768` to `32767`             | 2         | 16 位二进制有符号整数                          |
| [`Uint16Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Uint16Array)             | `0` to `65535`                  | 2         | 16 位无符号整数                             |
| [`Int32Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Int32Array)               | `-2147483648` to `2147483647`   | 4         | 32 位二进制有符号整数                          |
| [`Uint32Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Uint32Array)             | `0` to `4294967295`             | 4         | 32 位无符号整数                             |
| [`Float32Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Float32Array)           | `1.2`×`10-38` to `3.4`×`1038`   | 4         | 32 位 IEEE 浮点数（7 位有效数字，如 `1.1234567`）  |
| [`Float64Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Float64Array)           | `5.0`×`10-324` to `1.8`×`10308` | 8         | 64 位 IEEE 浮点数（16 有效数字，如 `1.123...15`) |
| [`BigInt64Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/BigInt64Array)         | `-263` to `263-1`               | 8         | 64 位二进制有符号整数                          |
| [`BigUint64Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/BigUint64Array)       | `0` to `264-1`                  | 8         | 64 位无符号整数                             |

可以看到在不同的视图下，主要差距是在内部单个元素的大小差距。当然越精确或者越大的数字占用的字节数越大，我们可以看以下例子来理解：

```javascript
const buffer = new ArrayBuffer(8) // 创建一段8字节的缓存
const view1 = new Int8Array(buffer) // 基于该缓存创建第一个8位类数组视图view1
view1[0] = 1 // 类似于普通数组，直接修改该数组元素
view1[1] = 2
console.log(view1) // Int8Array(8) [1, 2, 0, 0, 0, 0, 0, 0]
const view2 = new Int16Array(buffer) // 基于该缓存再创建一个16位类数组视图view2
console.log(view2[0]) // 请问打印多少?

// 具体的计算过程我们可以通过二进制算法得到，通过view1，我们操作了这段buffer的前两个字节分别
// 存储了1，2两个十进制数字。那么第一个字节码对应1:00000001,第二个字节码对应2：00000010
// 在view2中，一个元素就需要读取前两个字节码来确定。那么就需要把字节码1和字节码2合起来。
// 在视图中，是从右至左对应从高位到低位。那么view2[0]对应的二进制元素就是：1000000001
// 最后输出10进制:513
```

定型数组和普通数组一样，都支持一样的数组操作API例如map,filter,sort,some等。

### 5.1.10 集合对象 - Set,WeakSet

Set是ES6引入JS的新内置对象，Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会**出现一次**，即 Set 中的元素是唯一的。

所以Set对象的最大特点是：不重复。虽然Set本质上是无序的(因为你无法直接通过索引来访问元素)，但是由于它本身是可按插入顺序迭代(可迭代对象在第6章会详细介绍)的，所以实际上JS内部还是按照顺序对内部元素进行了存储。

而WeakSet则是弱对象的集合。之所以称为弱对象，是因为WeakSet只支持存储引用类型，并且对于内部元素是弱引用，即它内部的对象一旦在其他地方都没有引用了，那么该对象会被垃圾回收程序清理。所以对于内部元素的引用是及其"weak"的，而Set对于内部的元素就是强引用，所以Set内部存储的元素在Set被清理之前都不会被清理。而正是由于WeakSet的弱引用性质，所以WeakSet是不可迭代对象，因为在迭代过程中元素可能会因为外部失去引用而被清理。

### 5.1.11 键值对对象 - Map, WeakMap

Map同样是ES6引入JS的对象。Map内部的元素以键值对的形式存在，键值对的键和值可以是任何数据。但是内部的键不能重复。

和Set一样，虽然内部元素本质上是无序的，但是依然支持按照插入顺序进行迭代。

Map和Object都是内部以键值对的形式存储数据，在ES6以前，只能通过Object来实现Map。但是我们依然要知道，既然引入了Map，那必然是补足了Object在某些方面存在的缺陷，或者使用Map来专门完成某项任务，下表是相关的差别\[4]：

![](<.gitbook/assets/image (2) (1).png>)

可以看出对于键值对类型来说，Map的支持无论从类型广度，插入顺序的保留，Size获取，迭代支持，性能方面均优于Object。所以单纯从键值对容器的角度来评价，Map是优于Object的。那么Object既然这么不如Map，那么它的存在价值在哪里呢？

那正是因为Object本质是JS利用原型链实现对象式编程的载体，和Map作为纯容器不一样。Object对象是可以继承其他对象的键值对的，正是因为继承特性，所以Object是不能被替代的，更不用说Object的'.'操作符可以直接链式访问某些value的特性了，因为Map内部是既不支持'.'也不支持'\[]'访问(当然因为key可以是任何类型，所以也很难支持'.'访问),只能通过get()方法来访问某key对应的value。&#x20;

那么经过分析，Map更适合做单纯的键值对容器，而Object则应该回归以往的本质：基于原型链的对象属性和方法的容器。

WeakMap同WeakSet一样，内部对于key的引用是弱引用，所以不支持迭代，也不能返回size。

### 5.1.12 结构化数据对象 - JSON、ArrayBuffer、SharedArrayBuffer、Atomics、DataView

这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON （JavaScript Object Notation）编码的数据。

JSON对象其实是不同语言沟通的桥梁，不止可以被JS解析。所以JSON的两个静态方法JSON.parse()和JSON.stringify()是用来解析和编码JSON对象的,除此之外，JSON并不是一个构造函数。JSON总的来说是一般的对象和数组的结构化对象。

ArrayBuffer在前面就已经介绍过，表示内存上通用的、固定长度的原始二进制数据缓冲区，由于内部可以被分段，所以是一种非连续二进制数据的结构化对象。

SharedArrayBuffer和ArrayBuffer一样，表示内存上一个通用的，固定长度的原始二进制数据缓冲区，不同点在于SharedArrayBuffer不能被分割。

Atomics对象提供了一组静态方法来对ArrayBuffer/SharedArrayBuffer对象进行原子操作。原子操作指多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断，即原子操作是单线程的。另外原子操作提供等待wait()和通知notify()方法，可以让进程一直等待到某个特定条件为真，有点像Promise等待异步任务返回结果的过程。&#x20;

DataView对象提供了一组操作ArrayBuffe内部数据的API。它提供一组不同的set/get方法以向ArrayBuffe写入/读取不同范围的二进制数据。

由于在实际开发中这类对象用的场合比较少，所以这里就不再赘述。

### 5.1.13 异步编程控制对象 - Promise、Generator、GeneratorFunction、AsyncFunction

ES6引入了Promise的概念：一个 Promise对象代表一个在这个 promise 被创建出来时不一定已知的值。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 _promise_，以便在未来某个时候把值交给使用者。Promise在11章<<期约与异步>>里面有详细解释。

生成器Generator是一个负责抛出异步数据的函数，由生成器函数GeneratorFunction返回。

生成器函数GeneratorFunction是专门生成新的生成器函数的构造器。

AsyncFunction是专门创建新的异步函数对象的构造器，实际上可以直接在声明一个函数时在前面加上async关键字，代表该函数是一个异步函数，比直接使用生成器要方便的多。

```javascript
/// 建议使用的异步函数声明方式
async function[name]([param1[, param2[, ..., paramN]]]){
    statements 
}
```

### 5.1.14 代理和反射对象 - Proxy、Reflect

Proxy & Reflect 是ES6引入新对象：

Reflect中文含义是反射，意思是可以把所有对对象的操作通过Reflect反射到对象上，属于元编程的范畴。

实际上Reflect和Object上的方法很多都是重合的，相当于Reflect是专门把Object上的一部分方法抽取出来。因为Object作为一般对象的构造函数，它承担的任务太多了，需要把元编程这部分的API单独放在Reflect当中更合适。

Reflect本身不是一个构造函数，即不能被实例化。Reflect的方法如下\[5]:

* Reflect.apply(target, thisArg, args)
* Reflect.construct(target, args)
* Reflect.get(target, name, receiver)
* Reflect.set(target, name, value, receiver)
* Reflect.defineProperty(target, name, desc)
* Reflect.deleteProperty(target, name)
* Reflect.has(target, name)
* Reflect.ownKeys(target)
* Reflect.isExtensible(target)
* Reflect.preventExtensions(target)
* Reflect.getOwnPropertyDescriptor(target, name)
* Reflect.getPrototypeOf(target)
* Reflect.setPrototypeOf(target, prototype)

Proxy的中文含义是代理，即可以代理对某对象的操作: 拦截并重新定义在操作对象时的行为。Proxy是可以被实例化的。Proxy的方法如下：

* apply(target, object, args)
* construct(target, args)
* get(target, propKey, receiver)
* set(target, propKey, value, receiver)
* defineProperty(target, propKey, propDesc)
* deleteProperty(target, propKey)
* has(target, propKey)
* ownKeys(target)
* isExtensible(target)
* preventExtensions(target)
* getOwnPropertyDescriptor(target, propKey)
* getPrototypeOf(target)
* setPrototypeOf(target, proto)

可以看出Reflect和Proxy的方法是各自对应的，但是Proxy实际上使你可以自定义以上方法的行为，而Reflect代表的是JS内部定义的标准行为

红宝书第9章《代理和反射》详细解释了以上内容。

### 5.1.15 函数参数对象 - arguments

arguments 是一个对应于传递给函数的参数的类数组对象（除了箭头函数）。

arguments是当函数被调用时，在生成函数上下文的同时建立的对象，该对象存储了传入函数的参数的值。

该对象是可读可写的，所以如果你在函数内部定义了arguments对应位置的值，那么你传进去的参数值可能会被重写为内部定义的值。

可以通过arguments.caller获取调用当前函数的对象, 通过arguments.length来获取传入的参数个数。

### 5.1.16 国际化对象 - Intl

该对象下定义了很多的子对象用于进行国际化(字符，时间，数字)转换。像这样的顶层应用型对象这里就不再赘述了。

### 5.1.17 WASM对象 - WebAssembly

WebAssembly是一种新的二进制格式，它可以方便地将C/C等静态语言的代码快速地“运行”在浏览器中，这一特性为前端密集计算场景提供了无限可能。不仅如此，通过WebAssembly技术，我们还可以将基于Unity等游戏引擎开发的大型游戏快速地移植到Web端。WebAssembly技术现在已经被计划设计成W3C的标准，众多浏览器厂商已经提供了对其MVP版本标准的支持。在GoogleI/O2017大会上，Google首次针对WebAssembly技术进行了公开演讲和推广，其Post-MVP版本标准更是对诸如DOM操作、多线程和GC等特性提供了支持。

简单的说WebAssembly是一种网页虚拟机标准，使浏览器不仅只解析JS，还可以提供其他类型程序的运行环境，是一项全新的Web技术。

在JS里也提供了WASM相关的API以运行和调试相关WebAssembly代码。

## _本章需要你掌握的问题_

1. Global对象,window对象，GlobalThis对象的关系？
2. 列举几个ES6引入的新内置对象？
3. 原始值为什么可以直接调用方法？
4. 为什么1.toString()会报错而true.toString()不会报错？
5. Map和Object的异同？
6. 谈一谈arguments对象的含义和作用？
7. 尽量说一下ArrayBuffer，DataView，TypedArray的关系。

#### 参考资料:

\[1][https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular\_Expressions](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular\_Expressions), _MDN-正则表达式_

\[2][https://zhuanlan.zhihu.com/p/28058115](https://zhuanlan.zhihu.com/p/28058115), _前端博客_

\[3][https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/TypedArray](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/TypedArray)

\[4][https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Map)

\[5][https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Reflect](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global\_Objects/Reflect)
